{{define "function"}}
{{- $f := .}}

func {{.TestName}}(t *testing.T) {

	mockUsecase, mockUsecaseErr := new(MockUsecase), new(MockUsecase)

	// TODO: implement mock method
	mockUsecase.On("/** TODO: fill with method name*/").Return(/** TODO: fill with method's return value */)
	mockUsecaseErr.On("/** TODO: fill with method name*/").Return(/** TODO: fill with method's return value */)

	{{- with .Receiver}}
		{{- if .IsStruct}}
			{{- if .Fields}}
				type fields struct {
				{{- range .Fields}}
					{{Field .}} {{.Type}}
				{{- end}}
				}
			{{- end}}
		{{- end}}
	{{- end}}
	{{- if .TestParameters}}
	type args struct {
		{{- range .TestParameters}}
				{{Param .}} {{.Type}}
		{{- end}}
	}
	{{- end}}
	tests := []struct {
		name string
		{{- with .Receiver}}
			{{- if and .IsStruct .Fields}}
				fields fields
			{{- else}}
				{{Receiver .}} {{.Type}}
			{{- end}}
		{{- end}}
		{{- if .TestParameters}}
			args args
		{{- end}}
		{{- range .TestResults}}
			{{Want .}} {{.Type}}
		{{- end}}
			wantStatus int
			wantBody handlers.Response[/** TODO: change to concrete entity type →→→ */any]
		{{- if .ReturnsError}}
			wantErr bool
		{{- end}}
	}{
		// TODO: Add test cases.
	}
	for {{if (or .Subtests (not .IsNaked))}} _, tt := {{end}} range tests {
		{{- if .Subtests}}
		{{- if .Parallel}}tt := tt{{end}}
		t.Run(tt.name, func(t *testing.T) {
			{{- if .Parallel}}t.Parallel(){{end}}
		{{- end}}
			{{- with .Receiver}}
				{{- if .IsStruct}}
					{{Receiver .}} := {{if .Type.IsStar}}&{{end}}{{.Type.Value}}{
					{{- range .Fields}}
						{{.Name}}: tt.fields.{{Field .}},
					{{- end}}
					}
				{{- end}}
			{{- end}}
			{{- range .Parameters}}
				{{- if .IsWriter}}
					{{Param .}} := &bytes.Buffer{}
				{{- end}}
			{{- end}}
			{{- if and (not .OnlyReturnsError) (not .OnlyReturnsOneValue) }}
				{{template "results" $f}} {{template "call" $f}}
			{{- end}}
			{{- if .ReturnsError}}
				if {{if .OnlyReturnsError}} err := {{template "call" $f}}; {{end}} (err != nil) != tt.wantErr {
					t.Errorf("{{template "message" $f}} error = %v, wantErr %v", {{template "inputs" $f}} err, tt.wantErr)
					{{- if .TestResults}}
						{{if .Subtests }}return{{else}}continue{{end}}
					{{- end}}
				}
			{{- end}}

			// Setup gin context
			w := httptest.NewRecorder()
			c, _ := gin.CreateTestContext(w)

			got := {{template "inline" $f}} 

			// Assert status code
			if !reflect.DeepEqual(got.Writer.Status(), tt.wantStatus) {
				t.Errorf("{{template "message" $f}} = %v, wantStatus %v", {{template "inputs" $f}} got.Writer.Status(), tt.wantStatus)
			}

			// Assert response body
			var gotBody handlers.Response[/** TODO: change to concrete entity type →→→ */any]
			json.Unmarshal(w.Body.Bytes(), &gotBody)
			if !reflect.DeepEqual(gotBody, tt.wantBody) {
				t.Errorf("{{template "message" $f}} = %v, wantBody %v", {{template "inputs" $f}} gotBody, tt.wantBody)
			}

			t.Logf("{{.TestName}}: case「%v」", tt.name)
			t.Logf("Status: %v", got.Writer.Status())
			t.Logf("Response: %v", fmt.Sprintf("%+v", gotBody))

		{{- if .Subtests }} }) {{- end -}}
	}
}

{{end}}
